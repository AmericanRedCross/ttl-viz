<!--a1hwSmhvQWpVTlRjRmxJY3VVd1dRUTowZjliZmE3YTAzZmY3MjUy-->
<style>
</style>
<div id="data-collection-viewer">
  <!-- Header -->
  <div class="row">
  	<div class="columns">
  		<h2>Data Collection Viewer</h2>
  	</div>
    <div class="columns">
      <!-- Map -->
      <div id="viz">
        <div id="map" class="small-8 columns">
          <div id='bt'>
            <svg></svg>
          </div>
          <div id='vt'></div>
          <div id='zoomGui'></div>
        </div>
        <div id='mly' class="small-4 columns"></div>
      </div>
    </div>
  </div>

</div>
<!-- d3-tile -->
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="//d3js.org/d3-tile.v0.0.min.js"></script>
<!-- helper libs -->
<script src="https://cdn.rawgit.com/devTristan/pbf/master/dist/pbf.min.js"></script>
<script src="https://rawgit.com/devTristan/vector-tile-js/master/dist/vectortile.min.js"></script>
<!-- mapillary viewer -->
<script src='https://unpkg.com/mapillary-js@2.5.0/dist/mapillary.min.js'></script>
<link href='https://unpkg.com/mapillary-js@2.5.0/dist/mapillary.min.css' rel='stylesheet'/>

<script>

// d3-tile map //

var pi = Math.PI,
    tau = 2 * pi;

var width = Math.max(960, $("#viz").innerWidth()-100),
    height = Math.max(500, $("#viz").innerHeight());

var projection = d3.geoMercator()
    .scale(1/tau)
    .translate([0, 0]);

var path = d3.geoPath()
    .projection(projection);

var tile = d3.tile()
    .size([width, height]);

var zoom = d3.zoom()
    .scaleExtent([1 << 15, 1 << 23])
    .on("zoom", zoomed);

var zoomGui = d3.select("#zoomGui")
zoomGui.append('span')
  .classed('zoomIn',true)
  .text('+')
  .on('click',function() {
    zoom.scaleBy(svg, 2)
  })
zoomGui.append('span')
  .classed('zoomOut',true)
  .text('-')
  .on('click',function(){
    zoom.scaleBy(svg,0.5)
  })

// zoom controls
// TODO: make zoom controls remove svg on click, zoom in, redo 'zoom'

// var zoomControl = d3.select('#viz').append('div')
//   .attr('class','zoomContainer')
//
// var zoomIn = zoomControl.append('a')
//   .attr('class','zoom')
//   .attr('id','zoomIn')
//   .text('+')
//
// var zoomOut = zoomControl.append('a')
//   .attr('class','zoom')
//   .attr('id','zoomOut')
//   .text('-')

//disable mousewheel zoom if iframed
if (window.self !== window.top) {
  map.on("wheel.zoom", null);

  document.documentElement.className += ' mapzen-demo-iframed';
}

var svg = d3.select("#bt svg")
    .attr("width",width)
    .attr("height",height)

var vectorTilesDiv = d3.select("#vt")

var raster = svg.append("g")

// d3.select("body").append("div")
//     .attr("class", "info")
//     .html('<a href="http://bl.ocks.org/mbostock/5593150" target="_top">Mike Bostock</a> | <a href="https://github.com/mapzen/d3-vector-tiles">Mapzen</a> | Â© <a href="https://www.openstreetmap.org/copyright" target="_top">OpenStreetMap contributors</a> | <a href=" https://www.mapillary.com" title="Mapillary, CC BY" target="_top">Tiles Courtesy of Mapillary</a>')

function zoomed() {

  var transform = d3.event.transform;

  var tiles = tile
      .scale(transform.k)
      .translate([transform.x,transform.y])
      ();

  projection
    .scale(transform.k/tau)
    .translate([transform.x,transform.y]);

  var image = raster
      .attr("transform", stringify(tiles.scale, tiles.translate))
    .selectAll("image")
    .data(tiles, function(d) { return d; });

  image.exit()
    .remove();

  image.enter().append("image")
      .attr('class','baseTile')
      .attr("xlink:href", function(d) { return "http://" + "abc"[d[1] % 3] + ".tile.openstreetmap.org/" + d[2] + "/" + d[0] + "/" + d[1] + ".png"; })
      .attr("x", function(d) { return d[0] * 256; })
      .attr("y", function(d) { return d[1] * 256; })
      .attr("width", 256)
      .attr("height", 256);

  var vectorTilesData = vectorTilesDiv
      .style("transform", stringifyVT(tiles.scale, tiles.translate))
    .selectAll(".vTile")
    .data(tiles, function(d) { return d; });

  vectorTilesData.exit()
    .each(function(d) {
    //   baseVals = false
    //   if(d3.select(this)['_groups'][0][0]['children'].length>0){
    //     paths = d3.select(this)['_groups'][0][0]['children']
    //     for(i=0;i<paths.length;i++){
    //       baseVal = paths[i.toString()]['className']['baseVal']
    //       if(baseVal === 'point') {
    //         baseVals = true
    //       }
    //     }
    //   }
    //   if(baseVals){
        this._xhr.abort()
      // };
    })
    .remove();

  vectorTilesData.enter().append("svg")
    .attr("class","vTile")
    .style("left", function(d) { return d[0] * 256 + "px"})
    .style("top", function(d) { return d[1] * 256 + "px"})
    .each(function(d) {
      this._xhr = render(d,this)
    })


}

function stringify(scale, translate) {
  var k = scale / 256, r = scale % 1 ? Number : Math.round;
  return "translate(" + r(translate[0] * scale) + "," + r(translate[1] * scale) + ") scale(" + k + ")";
}

function stringifyVT(scale, translate) {
  var k = scale / 256, r = scale % 1 ? Number : Math.round;
  return "matrix3d(" + [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, r(translate[0] * scale), r(translate[1] * scale), 0, 1 ] + ")";
}

// different mapillary layers of interest http://bit.ly/2ptvROZ
var layers = ['mapillary-sequence-overview', 'mapillary-sequences', 'mapillary-images'];
var mapillaryImages = []
// function that grabs relevant vector tile, converts it to geojson, and adds as to vectorTiles group
function render(d, node) {
  return d3.request("http://d25uarhxywzl1j.cloudfront.net/v0.1/" + d[2] + "/" + d[0] + "/" + d[1] + ".mvt").responseType('arraybuffer').get(function(error, json) {
    if (error) {
      // 403 errors are ok, just means there aren't data in that tile
      throw error
    }
    console.log(d[2] + "/" + d[0] + "/" + d[1])
    var tile = new VectorTile( new pbf( new Uint8Array(json.response) ) );
    var extents = 4096;
    var geoJSON = {};
    for (var key in tile.layers) {
      geoJSON[key] = tile.layers[key].toGeoJSON();
    }

    // get tile values, make them fraction of extents,
    // multiply by 256 for tile h/w
    var tileProjection = d3.geoTransform({
      point: function(x,y){
        if(!isNaN(y)) {
          x = (x/extents) * 256
          y = (y/extents) * 256
        } else {
          y = (x[0][1]/extents) * 256
          x = (x[0][0]/extents) * 256
        }
        this.stream.point(x,y);
      }
    })

    var tilePath = d3.geoPath().projection(tileProjection)

    var features = [];
    layers.forEach(function(layer){
      if(geoJSON[layer]){
        for(var j in geoJSON[layer].features){
          features.push(geoJSON[layer].features[j]);
          console.log(geoJSON[layer].features[j])
        }
      }
    })

    if(d[2] === 14) {mapillaryImages = features}

    d3.select(node).selectAll("path")
      .data(features.sort(function(a,b) {
        return a.properties.ca > 0 ? a.properties.ca - b.properties.sort_rank : 0
      }))
      .enter().append("path")
        .attr("class", function(d) {return d.properties.key; })
        .attr("d", tilePath)
        .on('mouseover', function() {
          this.parentElement.appendChild(this);
          d3.select(this).style("stroke",'rgba(255,255,255,1)')
        })
        .on('mouseout', function() {
          d3.select(this).style("stroke",'black')
        })
        .on('click', function() {
          mly.moveToKey(d3.select(this).attr("class"))
          .then(
            function(node){console.log(node.key)},
            function(error){console.error(error)});
        });
  });
};

// Compute the projected initial center. Here, phillipines
var center = projection([121.9216, 11.8444]);

// initialize the map
svg
  .call(zoom)
  .on("wheel.zoom", null)
  .call(zoom.transform, d3.zoomIdentity
    .translate(width / 2, height / 2)
    .scale(1 << 20)
    .translate(-center[0], -center[1]));

// mapillary viewer //

var mly = new Mapillary.Viewer(
  'mly',
  'a1hwSmhvQWpVTlRjRmxJY3VVd1dRUTowZjliZmE3YTAzZmY3MjUy',
  null
)

</script>
