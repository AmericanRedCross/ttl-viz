<!--a1hwSmhvQWpVTlRjRmxJY3VVd1dRUTowZjliZmE3YTAzZmY3MjUy-->
<style>
</style>
<div id="data-collection-viewer">
  <!-- Header -->
  <div class="row">
  	<div class="columns">
  		<h2>Data Collection Viewer</h2>
  	</div>
    <div class="columns">
      <!-- Map -->
      <div id="viz">
        <svg></svg>
      </div>
    </div>
  </div>

</div>
<!-- d3-tile -->
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="//d3js.org/d3-tile.v0.0.min.js"></script>
<!-- <script src="/js/d3.geo.tile.min.js"></script> -->
<script src="https://cdn.rawgit.com/devTristan/pbf/master/dist/pbf.min.js"></script>
<script src="https://rawgit.com/devTristan/vector-tile-js/master/dist/vectortile.min.js"></script>
<script src='//s3.amazonaws.com/assets-staging.mapzen.com/ui/components/bug/bug.min.js'></script>
<script>

var pi = Math.PI,
    tau = 2 * pi;

var width = Math.max(960, $("#viz").innerWidth()-100),
    height = Math.max(500, $("#viz").innerHeight());

var projection = d3.geoMercator()
    .scale(1/tau)
    .translate([0, 0]);

var path = d3.geoPath()
    .projection(projection);

var tile = d3.tile()
    .size([width, height]);

var zoom = d3.zoom()
    .scaleExtent([1 << 1, 1 << 23])
    .on("zoom", zoomed);

var svg = d3.select("svg")
    .attr("width",width)
    .attr("height",height)

// var vectorTilesDiv = d3.select("#viz")
//     .append("div")
//     .attr("class","vt")
//     .attr("height", height + "px")
//     .attr("width", width + "px")
//
// var vectorTilesSVG = vectorTilesDiv.append("svg")
//     .attr("height", height)
//     .attr("width", width)

var raster = svg.append("g")
var vectorTiles =  svg.append("g")

d3.select("#viz").append("div")
    .attr("class", "info")
    .html('<a href="http://bl.ocks.org/mbostock/5593150" target="_top">Mike Bostock</a> | <a href="https://github.com/mapzen/d3-vector-tiles">Mapzen</a> | Â© <a href="https://www.openstreetmap.org/copyright" target="_top">OpenStreetMap contributors</a> | <a href=" https://www.mapillary.com" title="Mapillary, CC BY" target="_top">Tiles Courtesy of Mapillary</a>')

function zoomed() {

  var transform = d3.event.transform;

  var tiles = tile
      .scale(transform.k)
      .translate([transform.x,transform.y])
      ();

  projection
    .scale(transform.k/tau)
    .translate([transform.x,transform.y]);
  console.log(tiles.scale)
  console.log()
  var image = raster
      .attr("transform", stringify(tiles.scale, tiles.translate))
    .selectAll("image")
    .data(tiles, function(d) { return d; });

  image.exit()
    .remove();

  image.enter().append("image")
      .attr('class','baseTile')
      .attr("xlink:href", function(d) { return "http://" + "abc"[d[1] % 3] + ".tile.openstreetmap.org/" + d[2] + "/" + d[0] + "/" + d[1] + ".png"; })
      .attr("x", function(d) { return d[0] * 256; })
      .attr("y", function(d) { return d[1] * 256; })
      .attr("width", 256)
      .attr("height", 256);

  var vectorTilesData = vectorTiles
      .attr("transform", stringifyVT(tiles.scale, tiles.translate))
    .selectAll(".vTile")
    .data(tiles, function(d) { return d; });

  vectorTilesData.exit().remove();

  vectorTilesData.enter().append("svg")
    .attr("class","vTile")
    .style("left", function(d) { return d[0] * 256 + "px"})
    .style("top", function(d) { return d[1] * 256 + "px"})
    .each(function(d) {this._xhr = render(d,this)})

}

function stringify(scale, translate) {
  var k = scale / 256, r = scale % 1 ? Number : Math.round;
  return "translate(" + r(translate[0] * scale) + "," + r(translate[1] * scale) + ") scale(" + k + ")";
}

function stringifyVT(scale, translate) {
  var k = scale / 256, r = scale % 1 ? Number : Math.round;
  return "matrix3d(" + [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, r(translate[0] * scale), r(translate[1] * scale), 0, 1 ] + ")";
}

// different mapillary layers of interest http://bit.ly/2ptvROZ
var layers = ['mapillary-sequence-overview', 'mapillary-sequences', 'mapillary-images'];
// function that grabs relevant vector tile, converts it to geojson, and adds as to vectorTiles group
// TODO: figure out the correct transformation of the vt coordinates from mapillary to pixel coords in div
// TODO: understand what's the best 'drawing order' for these linestrings found in sequences.
function render(d, node) {
  return d3.request("http://d25uarhxywzl1j.cloudfront.net/v0.1/" + d[2] + "/" + d[0] + "/" + d[1] + ".mvt").responseType('arraybuffer').get(function(error, json) {
    if (error) {
      // 403 errors are ok, just means there aren't data in that tile
      throw error
    }
    //console.log(d[0], d[1])
    var tile = new VectorTile( new pbf( new Uint8Array(json.response) ) );
    //console.log(tile)
    var extents = 4096;
    var geoJSON = {};
    for (var key in tile.layers) {
      geoJSON[key] = tile.layers[key].toGeoJSON();
    }
    var tileProjection = d3.geoTransform({
      point: function(x,y){
        if(!isNaN(y)) {
          x = x/extents*256;
          y = y/extents*256;
        } else {
          y = x[0][1]/extents*256
          x = x[0][1]/extents*256
        }
        this.stream.point(x,y);
      }
    })

    var tilePath = d3.geoPath().projection(tileProjection)
    var features = [];
    layers.forEach(function(layer){
      if(geoJSON[layer]){
        for(var j in geoJSON[layer].features){
          features.push(geoJSON[layer].features[j]);
        }
      }
    })
    console.log(features)
    // size of the world in pixels
    var k = Math.pow(2, d[2]) * 256;
    d3.select(node).selectAll("path")
      .data(features)
      .enter().append("path")
        .attr("class", function(d) {return d.properties.key; })
        .attr("d", tilePath);
  });
};

// Compute the projected initial center. Here, phillipines
var center = projection([121.9216, 11.8444]);

// initialize the map
svg
  .call(zoom)
  .call(zoom.transform, d3.zoomIdentity
  .translate(width / 2, height / 2)
  .scale(1<<20)
    .translate(-center[0], -center[1]));

</script>
